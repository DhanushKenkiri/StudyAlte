import { analyzeTextWithComprehend } from './comprehend';
import { bedrockClient } from './bedrock-client';

export interface Tag {
  id: string;
  name: string;
  category: 'topic' | 'skill' | 'difficulty' | 'format' | 'custom';
  confidence: number; // 0-1 score for auto-generated tags
  isUserGenerated: boolean;
  createdAt: string;
  usageCount: number;
}

export interface TaggingOptions {
  includeTopics?: boolean;
  includeSkills?: boolean;
  includeDifficulty?: boolean;
  includeFormat?: boolean;
  maxTags?: number;
  minConfidence?: number;
  language?: string;
}

export interface TaggingResult {
  tags: Tag[];
  metadata: {
    totalGenerated: number;
    autoGeneratedCount: number;
    userGeneratedCount: number;
    avgConfidence: number;
    processingTime: number;
    sources: string[];
  };
}

export interface VideoMetadata {
  title: string;
  description?: string;
  duration?: number;
  language?: string;
  category?: string;
}

/**
 * Main function to generate tags for content using multiple sources
 */
export async function generateContentTags(
  content: string,
  videoMetadata: VideoMetadata,
  options: TaggingOptions = {}
): Promise<TaggingResult> {
  const startTime = Date.now();
  
  try {
    // Default options
    const {
      includeTopics = true,
      includeSkills = true,
      includeDifficulty = true,
      includeFormat = true,
      maxTags = 20,
      minConfidence = 0.5,
      language = 'en'
    } = options;

    // Generate tags from multiple sources
    const [
      comprehendTags,
      bedrockTags
    ] = await Promise.allSettled([
      generateComprehendTags(content, { minConfidence }),
      generateBedrockTags(content, videoMetadata, options)
    ]);

    // Combine and deduplicate tags
    const allTags: Tag[] = [];
    
    if (comprehendTags.status === 'fulfilled') {
      allTags.push(...comprehendTags.value.topics, ...comprehendTags.value.skills);
    }
    
    if (bedrockTags.status === 'fulfilled') {
      allTags.push(...bedrockTags.value.topics, ...bedrockTags.value.skills);
    }

    // Remove duplicates and apply filtering
    const uniqueTags = removeDuplicateTags(allTags);
    const filteredTags = uniqueTags
      .filter(tag => tag.confidence >= minConfidence)
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, maxTags);

    const processingTime = Date.now() - startTime;

    const result: TaggingResult = {
      tags: filteredTags,
      metadata: {
        totalGenerated: filteredTags.length,
        autoGeneratedCount: filteredTags.filter(tag => !tag.isUserGenerated).length,
        userGeneratedCount: filteredTags.filter(tag => tag.isUserGenerated).length,
        avgConfidence: filteredTags.reduce((sum, tag) => sum + tag.confidence, 0) / filteredTags.length,
        processingTime,
        sources: ['comprehend', 'bedrock'],
      },
    };

    return result;

  } catch (error) {
    // Content tagging failed
    throw error;
  }
}

/**
 * Generate tags using AWS Comprehend
 */
async function generateComprehendTags(
  content: string,
  options: { minConfidence: number }
): Promise<{ topics: Tag[]; skills: Tag[] }> {
  try {
    const analysis = await analyzeTextWithComprehend(content);
    
    const topics: Tag[] = analysis.keyPhrases
      .filter(phrase => phrase.score > 0.8)
      .slice(0, 5)
      .map((phrase, index) => ({
        id: `comprehend-phrase-${index}`,
        name: phrase.text.toLowerCase(),
        category: 'topic' as const,
        confidence: phrase.score,
        isUserGenerated: false,
        createdAt: new Date().toISOString(),
        usageCount: 0,
      }));

    const skills: Tag[] = analysis.entities
      .filter(entity => 
        ['TITLE', 'ORGANIZATION', 'OTHER'].includes(entity.type) &&
        entity.score > 0.7
      )
      .slice(0, 3)
      .map((entity, index) => ({
        id: `comprehend-entity-${index}`,
        name: entity.text.toLowerCase(),
        category: 'skill' as const,
        confidence: entity.score,
        isUserGenerated: false,
        createdAt: new Date().toISOString(),
        usageCount: 0,
      }));

    return { topics, skills };
  } catch (error) {
    // Comprehend tagging failed, using fallback
    return { topics: [], skills: [] };
  }
}

/**
 * Generate tags using AWS Bedrock
 */
async function generateBedrockTags(
  content: string,
  videoMetadata: VideoMetadata,
  options: TaggingOptions
): Promise<{ topics: Tag[]; skills: Tag[] }> {
  const prompt = `
Analyze this educational content and generate relevant tags:

Title: ${videoMetadata.title}
Content: ${content.substring(0, 2000)}

Generate tags in these categories:
- Topics: Main subjects and themes covered
- Skills: Technical skills, concepts, or abilities taught

Respond with JSON in this format:
{
  "topics": ["topic1", "topic2", ...],
  "skills": ["skill1", "skill2", ...]
}

Focus on educational value and learning outcomes.
`;

  try {
    const response = await bedrockClient.generateStructuredResponse(
      prompt,
      JSON.stringify({
        type: 'object',
        properties: {
          topics: {
            type: 'array',
            items: { type: 'string' }
          },
          skills: {
            type: 'array',
            items: { type: 'string' }
          }
        }
      }),
      {
        maxTokens: 500,
        temperature: 0.3
      }
    );

    if (!response) {
      throw new Error('No response from Bedrock');
    }

    const result = response as { topics?: string[]; skills?: string[] };
    
    const topics: Tag[] = (result.topics || []).map((topic: string, index: number) => ({
      id: `bedrock-topic-${index}`,
      name: topic.toLowerCase().trim(),
      category: 'topic' as const,
      confidence: 0.85, // High confidence for Bedrock tags
      isUserGenerated: false,
      createdAt: new Date().toISOString(),
      usageCount: 0,
    }));

    const skills: Tag[] = (result.skills || []).map((skill: string, index: number) => ({
      id: `bedrock-skill-${index}`,
      name: skill.toLowerCase().trim(),
      category: 'skill' as const,
      confidence: 0.85,
      isUserGenerated: false,
      createdAt: new Date().toISOString(),
      usageCount: 0,
    }));

    return { topics, skills };
  } catch (error) {
    // Bedrock tagging failed, using fallback
    return { topics: [], skills: [] };
  }
}

/**
 * Remove duplicate tags based on name similarity
 */
function removeDuplicateTags(tags: Tag[]): Tag[] {
  const seen = new Set<string>();
  const unique: Tag[] = [];

  for (const tag of tags) {
    const normalizedName = tag.name.toLowerCase().trim();
    if (!seen.has(normalizedName)) {
      seen.add(normalizedName);
      unique.push(tag);
    }
  }

  return unique;
}

/**
 * Add a user-generated tag
 */
export async function addUserTag(
  contentId: string,
  tagName: string,
  category: Tag['category'] = 'custom'
): Promise<Tag> {
  const tag: Tag = {
    id: `user-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    name: tagName.toLowerCase().trim(),
    category,
    confidence: 1.0, // User tags have full confidence
    isUserGenerated: true,
    createdAt: new Date().toISOString(),
    usageCount: 1,
  };

  // In a real implementation, you would save this to DynamoDB
  // await saveTagToDatabase(contentId, tag);

  return tag;
}

/**
 * Update tag usage count
 */
export async function updateTagUsage(tagId: string): Promise<void> {
  // In a real implementation, you would update the usage count in DynamoDB
  // await incrementTagUsageInDatabase(tagId);
}
